#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const readline = require('readline');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

const RULES_DIR = path.join(__dirname, '../rules');
const OUTPUT_FILE = path.join(RULES_DIR, 'tech_stack.md');

// Heuristics
const CHECKS = {
    'Python': ['requirements.txt', 'pyproject.toml', 'Pipfile', 'manage.py'],
    'Node.js': ['package.json', 'yarn.lock'],
    'Java': ['pom.xml', 'build.gradle', 'gradlew'],
    'Go': ['go.mod', 'main.go'],
    'Rust': ['Cargo.toml'],
    'Docker': ['Dockerfile', 'docker-compose.yml'],
    'Terraform': ['main.tf']
};

const FRAMEWORKS = {
    'Django': ['manage.py'],
    'Next.js': ['next.config.js'],
    'React': ['src/App.jsx', 'src/App.tsx'],
    'Spring Boot': ['mvnw', 'gradlew'], // Generic but often implies Spring
    'FastAPI': ['main.py']
};

function analyzeDirectory(targetPath) {
    console.log(`\nüîç Analyzing project at: ${targetPath}`);

    if (!fs.existsSync(targetPath)) {
        console.error("‚ùå Target path does not exist.");
        return null;
    }

    const files = fs.readdirSync(targetPath);
    const detectedLangs = [];
    const detectedFrameworks = [];

    // Language Detection
    for (const [lang, signatures] of Object.entries(CHECKS)) {
        if (signatures.some(sig => files.includes(sig) || fs.existsSync(path.join(targetPath, sig)))) {
            detectedLangs.push(lang);
        }
    }

    // Framework Detection (Simplistic)
    // Deep scan for frameworks might require reading package.json content, but filename check is fast.
    for (const [fw, signatures] of Object.entries(FRAMEWORKS)) {
        if (signatures.some(sig => files.includes(sig) || fs.existsSync(path.join(targetPath, sig)))) {
            detectedFrameworks.push(fw);
        }
    }

    // Git Detection
    const hasGit = fs.existsSync(path.join(targetPath, '.git'));

    return { detectedLangs, detectedFrameworks, hasGit };
}

function generateMarkdown(results, targetPath) {
    const timestamp = new Date().toISOString();
    const langs = results.detectedLangs.length > 0 ? results.detectedLangs.join(', ') : 'Generic/Unknown';
    const frameworks = results.detectedFrameworks.length > 0 ? results.detectedFrameworks.join(', ') : 'None Detected';
    const vcsStatus = results.hasGit ? 'Git' : 'None';

    return `# Project Tech Stack Context
> Generated by Antigravity Analyzer on ${timestamp}

## Target Project
- **Path**: \`${targetPath}\`
- **Primary Languages**: ${langs}
- **Frameworks**: ${frameworks}
- **VCS**: ${vcsStatus}

## Architectural Guidelines
1.  **Language**: Prefer **${langs}** idioms and best practices.
2.  **Framework**: Follow **${frameworks}** patterns (e.g., directory structure, naming conventions).
3.  **Dependency Management**: Use standard tools detected (npm, pip, maven, etc.).

## Constraints
- Ensure all code is compatible with the detected environment.
- Do not introduce foreign dependencies without user approval.
`;
}

async function main() {
    rl.question('\nüìÇ Enter the path of the project to analyze (Press Enter to skip): ', (answer) => {
        const targetPath = answer.trim();

        if (!targetPath) {
            console.log("‚ö†Ô∏è Skipping analysis. Using generic settings.");
            const genericContent = "# Project Tech Stack Context\n\n- **Type**: Generic\n- **Guideline**: Follow user instructions.";
            if (!fs.existsSync(RULES_DIR)) fs.mkdirSync(RULES_DIR, { recursive: true });
            fs.writeFileSync(OUTPUT_FILE, genericContent);
            console.log(`‚úÖ Default context written to ${OUTPUT_FILE}`);
            rl.close();
            return;
        }

        const absolutePath = path.isAbsolute(targetPath) ? targetPath : path.resolve(process.cwd(), targetPath);
        const results = analyzeDirectory(absolutePath);

        if (results) {
            console.log("‚úÖ Detection Results:");
            console.log(`   - Languages: ${results.detectedLangs.join(', ')}`);
            console.log(`   - Frameworks: ${results.detectedFrameworks.join(', ')}`);

            const mdContent = generateMarkdown(results, absolutePath);
            if (!fs.existsSync(RULES_DIR)) fs.mkdirSync(RULES_DIR, { recursive: true });
            fs.writeFileSync(OUTPUT_FILE, mdContent);
            console.log(`\nüìÑ Context file generated at: ${OUTPUT_FILE}`);
        }

        rl.close();
    });
}

main();
