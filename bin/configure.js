#!/usr/bin/env node

const fs = require('fs');
const path = require('path');
const readline = require('readline');

// The directory where antigravity-setup is installed (e.g., project/.agent/antigravity-setup)
const SETUP_DIR = path.resolve(__dirname, '..');

// Robust Project Root Detection
const hasGit = (dir) => fs.existsSync(path.join(dir, '.git'));
let PROJECT_ROOT;

// 1. Check if running from a target project (Global CLI Mode)
const CWD = process.cwd();
// If CWD is not the setup dir, and CWD has git, assume CWD is the target project.
if (path.relative(CWD, SETUP_DIR) !== '' && hasGit(CWD)) {
    PROJECT_ROOT = CWD;
}
// 2. Self-contained repo (Developing Antigravity itself)
else if (hasGit(SETUP_DIR)) {
    PROJECT_ROOT = SETUP_DIR;
}
// 3. Standard install (.agent/antigravity-setup)
else if (path.basename(path.dirname(SETUP_DIR)) === '.agent') {
    PROJECT_ROOT = path.resolve(SETUP_DIR, '../../');
}
// 4. Fallback
else {
    PROJECT_ROOT = path.resolve(SETUP_DIR, '../');
}

const CONTEXT_FILE = path.join(PROJECT_ROOT, 'AGENTS.md');

const rl = readline.createInterface({
    input: process.stdin,
    output: process.stdout
});

function askQuestion(query) {
    return new Promise(resolve => rl.question(query, resolve));
}

function generateContext() {
    // Relative path from ProjectRoot to SetupDir
    const relativeSetupPath = path.relative(PROJECT_ROOT, SETUP_DIR).replace(/\\/g, '/');
    // If relative path is empty (same directory), use "." to ensure valid paths (e.g. ./agents/...)
    const baseDir = relativeSetupPath || '.';

    return `
# Antigravity Agent Configuration
# Automatically generated by antigravity-setup

# 1. Identity & Protocol
You are an autonomous agent operating under the **Antigravity Protocol**.
Your goal is to build high-quality software by strictly following defined roles and workflows.

# 2. Context Loading
You MUST load and adhere to the following configurations:
- **Roles**: \`${baseDir}/agents/roles.yaml\`
- **Workflow**: \`${baseDir}/agents/workflow.md\`
- **Tech Stack**: \`${baseDir}/rules/tech_stack.md\` (Generated Context)
- **Language Rules**: \`${baseDir}/rules/00_language.rules.md\`

# 3. Behavior Guidelines
- **Plan First**: Always use \`/plan\` before starting complex work.
- **Vibe Coding**: Follow the "Think-Run-Feedback" loop. Don't write too much without running.
- **MSA**: Keep agents and tools modular (\`rules/msa_architecture.rules.md\`).

# 4. Commands
- \`/plan\`: Start a new task.
- \`/tdd\`: Implement features (Red-Green-Refactor).
- \`/verify\`: Check quality.
- \`/learn\`: Save lessons.
- \`/trend\`: Check latest trends.

# 5. Tools
- Use the provided MCP tools and Slash Commands defined in \`${baseDir}/tools/commands.md\`.
`;
}

async function configureGitProvider() {
    console.log('\nüîó Configure Git Provider (MCP)');
    console.log('1) GitHub (Default)');
    console.log('2) Gitea');
    console.log('3) Skip');

    const choice = await askQuestion('Select Provider [1-3]: ');
    const mcpConfigPath = path.join(SETUP_DIR, 'mcp', 'mcp_config.json');

    if (!fs.existsSync(mcpConfigPath)) {
        console.warn('‚ö†Ô∏è mcp_config.json not found. Skipping MCP config.');
        return;
    }

    const mcpConfig = JSON.parse(fs.readFileSync(mcpConfigPath, 'utf8'));

    if (choice === '2') { // Gitea
        const giteaUrl = await askQuestion('Enter Gitea URL (e.g., https://gitea.com): ');
        const giteaToken = await askQuestion('Enter Gitea Access Token: ');

        console.log('\nSelect Gitea Execution Mode:');
        console.log('1) Docker (Recommended if installed)');
        console.log('2) Local Binary');
        const mode = await askQuestion('Select Mode [1-2]: ');

        // Remove GitHub if exists
        if (mcpConfig.mcpServers && mcpConfig.mcpServers.github) {
            delete mcpConfig.mcpServers.github;
        }

        if (mode === '2') { // Binary
            const binPath = await askQuestion('Enter absolute path to Gitea MCP binary: ');
            mcpConfig.mcpServers.gitea = {
                command: binPath,
                args: ["-t", "stdio", "--host", giteaUrl],
                env: {
                    "GITEA_ACCESS_TOKEN": giteaToken
                }
            };
        } else { // Docker (Default)
            mcpConfig.mcpServers.gitea = {
                command: "docker",
                args: [
                    "run", "-i", "--rm",
                    "-e", "GITEA_ACCESS_TOKEN",
                    "-e", "GITEA_HOST",
                    "docker.gitea.com/gitea-mcp-server"
                ],
                env: {
                    "GITEA_ACCESS_TOKEN": giteaToken,
                    "GITEA_HOST": giteaUrl
                }
            };
        }
        console.log('‚úÖ Gitea MCP configured.');

    } else if (choice === '3') { // Skip
        console.log('   Skipping Git provider configuration.');
        // Optionally disable github if previously enabled? 
        // For now, leave as is or remove if user explicitly wants to skip/disable.
        // Let's remove default github to be safe if they skip.
        if (mcpConfig.mcpServers && mcpConfig.mcpServers.github) {
            // delete mcpConfig.mcpServers.github; 
            // Actually, skipping might mean "don't change anything", but usually implies "I don't have one".
            // Let's keep it simple: Skip = Do nothing.
        }

    } else { // GitHub (Default)
        const token = await askQuestion('Enter GitHub Personal Access Token (Press Enter to set later): ');
        if (token.trim()) {
            if (mcpConfig.mcpServers && mcpConfig.mcpServers.github) {
                mcpConfig.mcpServers.github.env.GITHUB_PERSONAL_ACCESS_TOKEN = token.trim();
                console.log('‚úÖ GitHub Token configured.');
            }
        } else {
            console.log('   Token not provided. Please set GITHUB_PERSONAL_ACCESS_TOKEN in mcp_config.json later.');
        }
    }

    fs.writeFileSync(mcpConfigPath, JSON.stringify(mcpConfig, null, 2));
}

async function configureSwarm() {
    console.log('\nüêù Configure Antigravity Swarm');
    const enableSwarm = await askQuestion('Enable Swarm features? (Requires gemini CLI) [y/N]: ');

    if (enableSwarm.toLowerCase() !== 'y') {
        console.log('   Skipping Swarm configuration.');
        return;
    }

    // Check for Gemini CLI
    let hasGemini = false;
    try {
        const { spawnSync } = require('child_process');
        // Windows 'where', Unix 'which'
        const cmd = process.platform === 'win32' ? 'where' : 'which';
        const check = spawnSync(cmd, ['gemini'], { stdio: 'ignore' });
        hasGemini = check.status === 0;
    } catch (e) {
        hasGemini = false;
    }

    if (!hasGemini) {
        console.warn('\n‚ö†Ô∏è  "gemini" CLI not found in PATH.');
        console.warn('   Please install it (e.g., npm install -g @google/generative-ai) to use Swarm.');
    } else {
        console.log('‚úÖ "gemini" CLI detected.');
    }

    // Configure API Key
    const apiKey = await askQuestion('Enter GEMINI_API_KEY (Leave empty to skip): ');
    if (apiKey.trim()) {
        const envPath = path.join(PROJECT_ROOT, '.env');
        let envContent = '';
        if (fs.existsSync(envPath)) {
            envContent = fs.readFileSync(envPath, 'utf8');
        }

        if (!envContent.includes('GEMINI_API_KEY=')) {
            envContent += `\nGEMINI_API_KEY=${apiKey.trim()}\n`;
            fs.writeFileSync(envPath, envContent);
            console.log(`‚úÖ GEMINI_API_KEY saved to ${envPath}`);
        } else {
            console.log('‚ÑπÔ∏è  GEMINI_API_KEY already exists in .env. Skipping update.');
        }
    }
}


async function main() {
    console.log(`\n‚öôÔ∏è  Configuring Antigravity Context...`);
    console.log(`   Project Root detected at: ${PROJECT_ROOT}`);
    console.log(`   Antigravity installed at: ${SETUP_DIR}`);

    // Context Analysis & Git Detection logic could be here, but we are overriding with interactive config.

    // Interactive Git Configuration
    await configureGitProvider();

    // Interactive Swarm Configuration
    await configureSwarm();

    const contextContent = generateContext();

    if (fs.existsSync(CONTEXT_FILE)) {
        console.log(`\n‚ö†Ô∏è  AGENTS.md already exists at ${CONTEXT_FILE}`);
        const answer = await askQuestion('   Overwrite it? (y/N): ');
        if (answer.toLowerCase() === 'y') {
            fs.writeFileSync(CONTEXT_FILE, contextContent);
            console.log('‚úÖ AGENTS.md updated.');
        } else {
            console.log('   Skipping configuration.');
        }
    } else {
        const answer = await askQuestion(`\nüìù Create AGENTS.md in project root? (Y/n): `);
        if (answer.toLowerCase() !== 'n') {
            fs.writeFileSync(CONTEXT_FILE, contextContent);
            console.log('‚úÖ AGENTS.md created. Point your LLM to this file context!');
        } else {
            console.log('   Skipped.');
        }
    }

    rl.close();
}

main();
